# -*- coding: utf-8 -*-
"""Clean_PDB.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bKYbTiqtdPYGR4hRPqJp8IeC7GptRW_s
"""

#@title Upload + clean PDB files safely (keep one ligand) + ONE master CSV (robust to short lines)
from google.colab import files
import os, csv

ION_WAT = {'HOH','NA','K','CL','MG','ZN','CA','MN','FE','CU','BR','IOD','I','NI','HG','AG','CD','AU','PB','RB'}
STD_RNA = {'A','U','G','C'}  # canonical RNA

# Common modified RNA residue names -> standard mapping (extend as needed)
MOD_TO_STD = {
    # common modified RNA residues (PDB names) mapped to canonical base
    'PSU': 'U',   # pseudouridine
    '5MU': 'U',   # 5-methyluridine (example)
    'H2U': 'U',
    'H5U': 'U',
    '5MC': 'C',   # 5-methylcytosine
    'M2G': 'G',
    'M2A': 'A',
    '1MA': 'A',
    '2MA': 'A',
    'M2U': 'U',
    'MSE': None,  # methionine analogue (protein) - ignore for RNA logic
    # add more mappings as you encounter them...
}

def pad80(line: str) -> str:
    """Return line padded/truncated to 80 chars for safe PDB slicing."""
    line = line.rstrip('\n')
    return (line + ' ' * (80 - len(line)))[:80]

def record_type(line: str) -> str:
    return pad80(line)[:6].strip().upper()

def get_resname(line: str) -> str:
    return pad80(line)[17:20].strip()

def get_chain(line: str) -> str:
    # Chain ID is column 22 (0-based index 21); after pad80 this is safe
    return pad80(line)[21].strip()

def map_resname_to_standard(resname: str):
    """
    Map a (possibly modified) residue name to canonical RNA base A/C/G/U.
    Returns the standard single-letter residue (A/C/G/U) or None if not mappable.
    """
    if not resname:
        return None
    r = resname.upper()
    if r in STD_RNA:
        return r
    if r in MOD_TO_STD:
        return MOD_TO_STD[r]  # may be None if intentionally unmapped
    # fallback heuristic: if first letter corresponds to a canonical base, use it
    first = r[0]
    if first in STD_RNA:
        return first
    # fallback: try to find any canonical base letter inside name
    for ch in r:
        if ch in STD_RNA:
            return ch
    return None

def detect_ligands(input_pdb_path):
    """Return sorted list of (resname, chain) for non-ion/non-water HETATMs."""
    ligands = set()
    with open(input_pdb_path, 'r', errors='ignore') as infile:
        for raw in infile:
            rec = record_type(raw)
            if rec != 'HETATM':
                continue
            resname = get_resname(raw)
            chain = get_chain(raw)
            if resname.upper() not in ION_WAT:
                ligands.add((resname, chain))
    return sorted(ligands)

def replace_resname_in_line(line80: str, new_resname: str) -> str:
    """Return a new 80-char padded line where columns 17-19 are replaced with new_resname (right aligned as in PDB)."""
    # PDB residue name field is cols 18-20 (1-based) -> indices 17:20
    new = list(line80)
    # prepare 3-char field (right-justified)
    new_r = new_resname.rjust(3) if new_resname else '   '
    new[17:20] = list(new_r)
    return ''.join(new)

def clean_pdb_selective(input_pdb_path, output_pdb_path, selected_ligand):
    """
    Keep only:
      - ATOM lines for standard RNA nucleotides (A,U,G,C) AFTER mapping modified residues to standard
      - HETATM lines for the selected ligand (by resname+chain) - ligand lines are NOT remapped
      - TER/END/MODEL/ENDMDL records are kept as is
    Also returns a dict of conversions observed for this file: {(orig_resname, chain, resseq): mapped}
    """
    sel_resname, sel_chain = selected_ligand
    kept = []
    conversions = {}  # record conversions: key -> mapped standard
    with open(input_pdb_path, 'r', errors='ignore') as infile:
        for raw in infile:
            rec = record_type(raw)
            line80 = pad80(raw)

            if rec in {'TER','END','MODEL','ENDMDL'}:
                kept.append(raw)  # preserve original formatting
                continue

            if rec == 'ATOM':
                # ATOM lines normally contain residues in columns 17:20
                orig_resname = line80[17:20].strip()
                mapped = map_resname_to_standard(orig_resname)
                if mapped:
                    # create new line with mapped residue name
                    new_line80 = replace_resname_in_line(line80, mapped)
                    # keep original newline character(s) if present in raw
                    kept.append(new_line80.rstrip() + '\n')
                    # store the conversion detail (multiple atoms of same residue will overwrite with same mapping)
                    # Try to capture residue sequence number to disambiguate if desired
                    resseq = line80[22:26].strip()
                    conversions[(orig_resname, line80[21].strip(), resseq)] = mapped
                else:
                    # not mappable to standard RNA -> skip atom
                    continue

            elif rec == 'HETATM':
                resname = line80[17:20].strip()
                chain = line80[21].strip()
                # If this HETATM is the selected ligand (match both resname & chain), keep as-is
                if (resname.upper() not in ION_WAT) and (resname == sel_resname) and (chain == sel_chain):
                    kept.append(raw)
                else:
                    # skip other hetatms (ions/waters/other ligands)
                    continue

            # ignore everything else (REMARK, ANISOU, etc.)

    with open(output_pdb_path, 'w') as out:
        out.writelines(kept)
        if not kept or kept[-1].strip() != 'END':
            out.write('END\n')
    return output_pdb_path, conversions

def safe_int_input(prompt, lo, hi, allow_zero=False):
    while True:
        try:
            val = int(input(prompt))
            if allow_zero and val == 0:
                return 0
            if lo <= val <= hi:
                return val
        except Exception:
            pass
        print(f"Please enter a number between {lo} and {hi}" + (" (or 0 to skip)" if allow_zero else "") + ".")

# -------- Upload & process --------
uploaded = files.upload()
master_rows = []
master_csv_path = "clean_summary_master.csv"

for filename in uploaded:
    print(f"\nðŸ” Ligands found in {filename}:")
    ligands = detect_ligands(filename)

    if not ligands:
        print("   (No non-ion/non-water HETATM ligands detected. Skipping.)")
        continue

    for idx, (resname, chain) in enumerate(ligands, start=1):
        print(f"  {idx}: Ligand {resname} in Chain {chain or '-'}")

    if len(ligands) == 1:
        choice = 1
        print("   Only one ligand found â†’ selecting automatically.")
    else:
        choice = safe_int_input("Enter the number of the ligand you want to keep (0 to skip this file): ",
                                1, len(ligands), allow_zero=True)
        if choice == 0:
            print("   Skipped.")
            continue

    sel_resname, sel_chain = ligands[choice - 1]
    base = os.path.splitext(os.path.basename(filename))[0]
    cleaned_path = f"{base}_cleaned.pdb"
    cleaned_path, conversions = clean_pdb_selective(filename, cleaned_path, (sel_resname, sel_chain))
    print(f"âœ… Cleaned PDB saved as: {cleaned_path}")
    files.download(cleaned_path)

    # summarize conversions into a compact string for the master CSV
    if conversions:
        # Build a sorted unique mapping summary like "PSU->U (chain A res123), 5MC->C (chain B res45)"
        conv_items = []
        seen = set()
        for (orig, chain, resseq), mapped in sorted(conversions.items(), key=lambda x: (x[0][1], x[0][2], x[0][0])):
            key = (orig, chain, resseq, mapped)
            if key in seen:
                continue
            seen.add(key)
            conv_items.append(f"{orig}->{mapped} (chain {chain or '-'} res {resseq})")
        conv_summary = "; ".join(conv_items)
    else:
        conv_summary = ""

    master_rows.append((base, sel_resname, sel_chain, conv_summary))

# write ONE master CSV at the end (includes conversions)
if master_rows:
    with open(master_csv_path, "w", newline="") as f:
        w = csv.writer(f)
        w.writerow(["PDB_ID","Ligand_name","Chain_ID","Residue_mappings"])  # new column
        w.writerows(master_rows)
    print(f"\nðŸ“˜ Master summary created: {master_csv_path}")
    files.download(master_csv_path)
else:
    print("\n(No ligands processed â†’ no master CSV produced.)")